{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Low-Code Real-Time Kafka Stream Processor Kahpp is a self-service Kafka Stream processor capable of filtering, transforming and routing Kafka records in real-time with a YAML file. Its most straightforward configuration lets you consume a topic and trigger HTTP API requests for each received message. At its more complex setup, it can filter, duplicate, route, re-process, and do much more based on a condition. Motivation Everything Kahpp does is achievable with Kafka Streams, but that comes with an overhead of code and knowledge. The motivation of this project is to simplify this process by using only a configuration file. Offering a centrally deployed configuration based service allows teams to quickly bridge the gap from starting a project to consuming a topic and running their code. In addition, from an infrastructure perspective, it allows more stability and gains the benefits of using Java for Kafka interactions. Powered By","title":"What is Kahpp?"},{"location":"#a-low-code-real-time-kafka-stream-processor","text":"Kahpp is a self-service Kafka Stream processor capable of filtering, transforming and routing Kafka records in real-time with a YAML file. Its most straightforward configuration lets you consume a topic and trigger HTTP API requests for each received message. At its more complex setup, it can filter, duplicate, route, re-process, and do much more based on a condition.","title":"A Low-Code Real-Time Kafka Stream Processor"},{"location":"#motivation","text":"Everything Kahpp does is achievable with Kafka Streams, but that comes with an overhead of code and knowledge. The motivation of this project is to simplify this process by using only a configuration file. Offering a centrally deployed configuration based service allows teams to quickly bridge the gap from starting a project to consuming a topic and running their code. In addition, from an infrastructure perspective, it allows more stability and gains the benefits of using Java for Kafka interactions.","title":"Motivation"},{"location":"#powered-by","text":"","title":"Powered By"},{"location":"developer-guide/spring-boot-starter/","text":"Kahpp Spring Boot Starter Spring Boot Starters are a set of convenient dependency descriptors that you can include in your application, there are plenty of Spring Starters out there, and we have one for Kahpp! You'll get everything for Kahpp and the related technology you need without doing manual copy and paste from codebase to codebase. To get started using Kahpp, include the kahpp-spring-starter dependency in your project. implementation \"dev.vox.platform.kahpp:kahpp-spring-starter:${KAHPP_VERSION}\" Repository We publish this starter on Github so you need to use the correct repository to be able to download it. repositories { mavenCentral() maven { url \"https://maven.pkg.github.com/GetFeedback/kahpp-oss\" } }","title":"Spring Boot Starter"},{"location":"developer-guide/spring-boot-starter/#kahpp-spring-boot-starter","text":"Spring Boot Starters are a set of convenient dependency descriptors that you can include in your application, there are plenty of Spring Starters out there, and we have one for Kahpp! You'll get everything for Kahpp and the related technology you need without doing manual copy and paste from codebase to codebase. To get started using Kahpp, include the kahpp-spring-starter dependency in your project. implementation \"dev.vox.platform.kahpp:kahpp-spring-starter:${KAHPP_VERSION}\"","title":"Kahpp Spring Boot Starter"},{"location":"developer-guide/spring-boot-starter/#repository","text":"We publish this starter on Github so you need to use the correct repository to be able to download it. repositories { mavenCentral() maven { url \"https://maven.pkg.github.com/GetFeedback/kahpp-oss\" } }","title":"Repository"},{"location":"features/filters/","text":"Filter Permits to filter records by specific field (key, value, timestamp, etc.) using jmespath . Usage examples A filter-like JMESPath evaluation - name: filterByValueName type: dev.vox.platform.kahpp.configuration.filter.FilterField config: jmesPath: \"value.name == 'foo'\" More complex JMESPath expression Filter all records that contains fooHeaderKey in the headers. - name: headerExists type: dev.vox.platform.kahpp.configuration.filter.FilterField config: jmesPath: >- { fooHeader: headers[].\"fooHeaderKey\" } | length(fooHeader) == `0` JMESPath functions We can make our filters more powerful using JMESPath functions. - now : permits addition or subtraction from now time for different units. - For example, we want to know the value (epoch millis) of yesterday, we can use \" now('-P1D') \"the result will be the epoch in millisecond unit of yesterday. - The operation is in ISO 8601 duration format (see more here ). Example Filter all records not older than 14 days ago - name: filterByTimestamp type: dev.vox.platform.kahpp.configuration.filter.FilterField config: jmesPath: \"timestamp > now('-P14D')\"","title":"Filters"},{"location":"features/filters/#filter","text":"Permits to filter records by specific field (key, value, timestamp, etc.) using jmespath .","title":"Filter"},{"location":"features/filters/#usage-examples","text":"A filter-like JMESPath evaluation - name: filterByValueName type: dev.vox.platform.kahpp.configuration.filter.FilterField config: jmesPath: \"value.name == 'foo'\" More complex JMESPath expression Filter all records that contains fooHeaderKey in the headers. - name: headerExists type: dev.vox.platform.kahpp.configuration.filter.FilterField config: jmesPath: >- { fooHeader: headers[].\"fooHeaderKey\" } | length(fooHeader) == `0`","title":"Usage examples"},{"location":"features/filters/#jmespath-functions","text":"We can make our filters more powerful using JMESPath functions. - now : permits addition or subtraction from now time for different units. - For example, we want to know the value (epoch millis) of yesterday, we can use \" now('-P1D') \"the result will be the epoch in millisecond unit of yesterday. - The operation is in ISO 8601 duration format (see more here ).","title":"JMESPath functions"},{"location":"features/filters/#example","text":"Filter all records not older than 14 days ago - name: filterByTimestamp type: dev.vox.platform.kahpp.configuration.filter.FilterField config: jmesPath: \"timestamp > now('-P14D')\"","title":"Example"},{"location":"features/http/","text":"HTTP Step Kahpp makes it possible to reach one or more HTTP Endpoints. Declare API client First, we need to declare the API client on the Kahpp instance. For example: kahpp: apis: my-dummy-api: # Logical name of the client basePath: http://my-dummy-api Then in the steps, we may decide how to use it and how to handle the response. Connection configurations Set the connection configuration based on connect and socket timeouts. kahpp: apis: my-dummy-api: # Logical name of the client basePath: http://my-dummy-api options: connection: connectTimeoutMillis: 300 socketTimeoutMs: 1500 name default description connectTimeoutMillis 500 Determines the timeout in milliseconds until a connection is established. socketTimeoutMs 2000 Defines the socket timeout in milliseconds, which is the timeout for waiting for data or, put differently, a maximum period inactivity between two consecutive data packets Request headers Set HTTP headers necessary for HTTP requests. kahpp: apis: my-dummy-api: basePath: http://my-dummy-api options: headers: Accept: text/html User-Agent: Mozilla/5.0 Connection: keep-alive Default header is Accept:application/json . Rate Limit Configure rate limiter for HTTP requests. If unset, no http request rate limit will be in place. kahpp: apis: my-dummy-api: basePath: http://my-dummy-api options: rateLimit: requestsPerSecond: 10 warmUpMillis: 100 name required description requestsPerSecond yes set how many request are available per second. warmUpMillis no the duration in milliseconds of the period where the RateLimiter ramps up its rate, before reaching its stable. Retry configuration If unset, the default retry policy will be in place. kahpp: apis: my-dummy-api: basePath: http://my-dummy-api options: retries: retryOnTimeout: true statusCodeRetryTimeSeedInMs: 1000 statusCodeRetryTimeCapInMs: 10000 statusCodes: - statusCodeStart: 500 statusCodeInclusiveEnd: 599 retries: 10 name default description connectionRetryCount 3 The amount of times to retry when the connection fails. retryIdempotentRequests true True if it's OK to retry non-idempotent requests that have been sent. retryOnTimeout false True if it should retry timeout errors. statusCodeRetryTimeSeedInMs 50 A seed in milliseconds used to calculate the backoff time. statusCodeRetryTimeCapInMs 1000 The cap of the backoff time statusCodeRetryMemory 25 The amount of requests that contribute to the backoff time calculation. statusCodes - statusCodeStart: 500 statusCodeInclusiveEnd: 599 retries: 3 - statusCode: 429 retries: 10 Strategy to retry responses with specific status codes. Simple HTTP Call This is the most straightforward HTTP call step. - name: simpleHttpCall type: dev.vox.platform.kahpp.configuration.http.SimpleHttpCall config: api: my-dummy-api path: /my/path Ok or Produce Error In case of error, it routes the message to a specific topic. Simple HTTP Call - name: httpCall type: dev.vox.platform.kahpp.configuration.http.OkOrProduceError config: api: my-dummy-api path: /my/path topic: error HTTP Call with response handler Update the field name with the HTTP Response - name: httpCall type: dev.vox.platform.kahpp.configuration.http.OkOrProduceError config: api: my-dummy-api path: /my/path topic: error responseHandler: type: RECORD_UPDATE jmesPath: value.name Handle by Status Code The response can also be handled in different ways based on the status code. - name: httpCall type: dev.vox.platform.kahpp.configuration.http.HandleByStatusCode config: api: my-dummy-api path: /my/path topic: error responseHandlers: - statusCodeStart: 412 statusCodeInclusiveEnd: 412 responseHandler: type: RECORD_ROUTE topics: - retriableErrors - error - statusCodeStart: 422 statusCodeInclusiveEnd: 422 responseHandler: type: RECORD_ROUTE topics: - unretriableErrors - error Optional parameters name default type description forwardRecordOnError false boolean In case of error, don't stop the pipeline, so the record will be forward to the next step. condition JMESPath JMESPath expression, if false the step will be skipped method POST POST,PUT,GET,PATCH HTTP method to use for the request. Response Handlers Name Description Additional Parameter Parameter description RECORD_FORWARD_AS_IS Forward record to the next step RECORD_UPDATE Replace record field with the HTTP Response body jmesPath Field to replace with the HTTP Response RECORD_TERMINATE Don't forward record to the next step RECORD_ROUTE Route record to specific topics topics List of topics to route the record to Configure dynamic path It's possible to configure the path dynamically using placeholders. The value correspondent to the placeholder need to be available inside the record. Example: config: api: my-dummy-api path: /my/path/${value.myDynamic.field} topic: error So record value needs to look like this: { \"myDynamic\": { \"field\": 1234 } } If the value is not there, the call will fail, and the record will be routed to the error topic. HTTP response errors If in an HTTP call an error occurs, it will be saved as a header on the record.","title":"Http"},{"location":"features/http/#http-step","text":"Kahpp makes it possible to reach one or more HTTP Endpoints.","title":"HTTP Step"},{"location":"features/http/#declare-api-client","text":"First, we need to declare the API client on the Kahpp instance. For example: kahpp: apis: my-dummy-api: # Logical name of the client basePath: http://my-dummy-api Then in the steps, we may decide how to use it and how to handle the response.","title":"Declare API client"},{"location":"features/http/#connection-configurations","text":"Set the connection configuration based on connect and socket timeouts. kahpp: apis: my-dummy-api: # Logical name of the client basePath: http://my-dummy-api options: connection: connectTimeoutMillis: 300 socketTimeoutMs: 1500 name default description connectTimeoutMillis 500 Determines the timeout in milliseconds until a connection is established. socketTimeoutMs 2000 Defines the socket timeout in milliseconds, which is the timeout for waiting for data or, put differently, a maximum period inactivity between two consecutive data packets","title":"Connection configurations"},{"location":"features/http/#request-headers","text":"Set HTTP headers necessary for HTTP requests. kahpp: apis: my-dummy-api: basePath: http://my-dummy-api options: headers: Accept: text/html User-Agent: Mozilla/5.0 Connection: keep-alive Default header is Accept:application/json .","title":"Request headers"},{"location":"features/http/#rate-limit","text":"Configure rate limiter for HTTP requests. If unset, no http request rate limit will be in place. kahpp: apis: my-dummy-api: basePath: http://my-dummy-api options: rateLimit: requestsPerSecond: 10 warmUpMillis: 100 name required description requestsPerSecond yes set how many request are available per second. warmUpMillis no the duration in milliseconds of the period where the RateLimiter ramps up its rate, before reaching its stable.","title":"Rate Limit"},{"location":"features/http/#retry-configuration","text":"If unset, the default retry policy will be in place. kahpp: apis: my-dummy-api: basePath: http://my-dummy-api options: retries: retryOnTimeout: true statusCodeRetryTimeSeedInMs: 1000 statusCodeRetryTimeCapInMs: 10000 statusCodes: - statusCodeStart: 500 statusCodeInclusiveEnd: 599 retries: 10 name default description connectionRetryCount 3 The amount of times to retry when the connection fails. retryIdempotentRequests true True if it's OK to retry non-idempotent requests that have been sent. retryOnTimeout false True if it should retry timeout errors. statusCodeRetryTimeSeedInMs 50 A seed in milliseconds used to calculate the backoff time. statusCodeRetryTimeCapInMs 1000 The cap of the backoff time statusCodeRetryMemory 25 The amount of requests that contribute to the backoff time calculation. statusCodes - statusCodeStart: 500 statusCodeInclusiveEnd: 599 retries: 3 - statusCode: 429 retries: 10 Strategy to retry responses with specific status codes.","title":"Retry configuration"},{"location":"features/http/#simple-http-call","text":"This is the most straightforward HTTP call step. - name: simpleHttpCall type: dev.vox.platform.kahpp.configuration.http.SimpleHttpCall config: api: my-dummy-api path: /my/path","title":"Simple HTTP Call"},{"location":"features/http/#ok-or-produce-error","text":"In case of error, it routes the message to a specific topic. Simple HTTP Call - name: httpCall type: dev.vox.platform.kahpp.configuration.http.OkOrProduceError config: api: my-dummy-api path: /my/path topic: error HTTP Call with response handler Update the field name with the HTTP Response - name: httpCall type: dev.vox.platform.kahpp.configuration.http.OkOrProduceError config: api: my-dummy-api path: /my/path topic: error responseHandler: type: RECORD_UPDATE jmesPath: value.name","title":"Ok or Produce Error"},{"location":"features/http/#handle-by-status-code","text":"The response can also be handled in different ways based on the status code. - name: httpCall type: dev.vox.platform.kahpp.configuration.http.HandleByStatusCode config: api: my-dummy-api path: /my/path topic: error responseHandlers: - statusCodeStart: 412 statusCodeInclusiveEnd: 412 responseHandler: type: RECORD_ROUTE topics: - retriableErrors - error - statusCodeStart: 422 statusCodeInclusiveEnd: 422 responseHandler: type: RECORD_ROUTE topics: - unretriableErrors - error","title":"Handle by Status Code"},{"location":"features/http/#optional-parameters","text":"name default type description forwardRecordOnError false boolean In case of error, don't stop the pipeline, so the record will be forward to the next step. condition JMESPath JMESPath expression, if false the step will be skipped method POST POST,PUT,GET,PATCH HTTP method to use for the request.","title":"Optional parameters"},{"location":"features/http/#response-handlers","text":"Name Description Additional Parameter Parameter description RECORD_FORWARD_AS_IS Forward record to the next step RECORD_UPDATE Replace record field with the HTTP Response body jmesPath Field to replace with the HTTP Response RECORD_TERMINATE Don't forward record to the next step RECORD_ROUTE Route record to specific topics topics List of topics to route the record to","title":"Response Handlers"},{"location":"features/http/#configure-dynamic-path","text":"It's possible to configure the path dynamically using placeholders. The value correspondent to the placeholder need to be available inside the record. Example: config: api: my-dummy-api path: /my/path/${value.myDynamic.field} topic: error So record value needs to look like this: { \"myDynamic\": { \"field\": 1234 } } If the value is not there, the call will fail, and the record will be routed to the error topic.","title":"Configure dynamic path"},{"location":"features/http/#http-response-errors","text":"If in an HTTP call an error occurs, it will be saved as a header on the record.","title":"HTTP response errors"},{"location":"features/produce/","text":"Produce Declare a topic First, we need to declare the topics on the Kahpp instance. It is mandatory to have one source topic named source For example: kahpp: topics: source: sport.topic sport-outdoors: sport-outdoors.topic sport-indoors: sport-indoors.topic error: error.topic Produce to a topic Permits to sink records to a specific topic. Usage example - name: produceRecordToSinkTopic type: dev.vox.platform.kahpp.configuration.topic.ProduceToTopic config: topic: sport-outdoors Routing Permits routing records to specific topic using jmespath . The routes are declared under routes with jmesPath as a matching condition and topic as the name for the topic to route the message to. If no route is matched, the record lands in errorTopic Usage examples A filter-like JMESPath evaluation using declared topics for routing - name: produceActionToSinkTopic type: dev.vox.platform.kahpp.configuration.topic.ProduceToTopicByRoute config: errorTopic: error routes: - jmesPath: value.sportType == 'outdoors' topic: sport-outdoors - jmesPath: value.sportType == 'indoors' topic: sport-indoors","title":"Produce"},{"location":"features/produce/#produce","text":"","title":"Produce"},{"location":"features/produce/#declare-a-topic","text":"First, we need to declare the topics on the Kahpp instance. It is mandatory to have one source topic named source For example: kahpp: topics: source: sport.topic sport-outdoors: sport-outdoors.topic sport-indoors: sport-indoors.topic error: error.topic","title":"Declare a topic"},{"location":"features/produce/#produce-to-a-topic","text":"Permits to sink records to a specific topic.","title":"Produce to a topic"},{"location":"features/produce/#usage-example","text":"- name: produceRecordToSinkTopic type: dev.vox.platform.kahpp.configuration.topic.ProduceToTopic config: topic: sport-outdoors","title":"Usage example"},{"location":"features/produce/#routing","text":"Permits routing records to specific topic using jmespath . The routes are declared under routes with jmesPath as a matching condition and topic as the name for the topic to route the message to. If no route is matched, the record lands in errorTopic","title":"Routing"},{"location":"features/produce/#usage-examples","text":"A filter-like JMESPath evaluation using declared topics for routing - name: produceActionToSinkTopic type: dev.vox.platform.kahpp.configuration.topic.ProduceToTopicByRoute config: errorTopic: error routes: - jmesPath: value.sportType == 'outdoors' topic: sport-outdoors - jmesPath: value.sportType == 'indoors' topic: sport-indoors","title":"Usage examples"},{"location":"features/step/","text":"What is a Step? We can think of a step as a single logic action in the pipeline. In other words, a step represents the smallest unit that, combined with other steps , shapes the pipeline. Step configuration All steps contains these fields: name , type and config . steps: - name: stepOneName type: step.one.type config: ### Configuration here - name: stepTwoName type: step.two.type config: ### Configuration here","title":"What is a Step?"},{"location":"features/step/#what-is-a-step","text":"We can think of a step as a single logic action in the pipeline. In other words, a step represents the smallest unit that, combined with other steps , shapes the pipeline.","title":"What is a Step?"},{"location":"features/step/#step-configuration","text":"All steps contains these fields: name , type and config . steps: - name: stepOneName type: step.one.type config: ### Configuration here - name: stepTwoName type: step.two.type config: ### Configuration here","title":"Step configuration"},{"location":"features/throttle/","text":"Throttle Limit the output of a KaHPP instance by applying a rate limit using recordsPerSecond . - name: throttle type: dev.vox.platform.kahpp.configuration.throttle.Throttle config: recordsPerSecond: 10","title":"Throttle"},{"location":"features/throttle/#throttle","text":"Limit the output of a KaHPP instance by applying a rate limit using recordsPerSecond . - name: throttle type: dev.vox.platform.kahpp.configuration.throttle.Throttle config: recordsPerSecond: 10","title":"Throttle"},{"location":"features/transformers/","text":"Transformers These steps make it possible to re-shape records on your need. Move Field Permits to move a field. - name: moveBarToNewBar type: dev.vox.platform.kahpp.configuration.transform.MoveFieldRecordTransform config: from: value.bar to: value.newBar Copy Field Permits to copy a field. - name: copyKeyToValue type: dev.vox.platform.kahpp.configuration.transform.CopyFieldRecordTransform config: from: key to: value.key Drop Field Permits to remove a field. - name: removeThisField type: dev.vox.platform.kahpp.configuration.transform.DropFieldRecordTransform config: jmesPath: value.unlike Convert ZonedDateTime Field Converts a date from one format to another. - name: ensureCreatedAtDateIsRFC3339 type: dev.vox.platform.kahpp.configuration.transform.ConvertZonedDateTimeFieldTransform config: field: value.createdAt inputFormat: RFC_3339_LENIENT_MS_FORMATTER outputFormat: RFC_3339 Extract Field Pulls a field out of a complex value and replaces the entire value with the extracted field. - name: extractId type: dev.vox.platform.kahpp.configuration.transform.ExtractFieldValueTransform config: field: id Split array Split an array into multiple records. Let's take as example this record: { \"customer\": \"Paolo\", \"orders\": [ { \"type\": \"food\", \"product\": \"pizza\" }, { \"type\": \"drink\", \"product\": \"cocacola\" } ] } We would like to send the order for food and drink in two different places (for example to two different topics). So the expected result is to have two records. One for the food: { \"customer\": \"Paolo\", \"order\": { \"type\": \"food\", \"product\": \"pizza\" } } Another for the drink: { \"customer\": \"Paolo\", \"order\": { \"type\": \"drink\", \"product\": \"cocacola\" } } So, our step configuration will look like: - name: splitFooArray type: dev.vox.platform.kahpp.configuration.transform.SplitValueTransform config: jmesPath: \"value.orders\" to: \"value.order\" # Optional field Optional configurations name default description to \"\" Defines where to put an extracted array's object as a nested field into the original parent object. If the 'to' field is not configured, the extracted object will go on the 'value' field by default. The existing parent's field under the same 'to' path is going to be overridden. Copy Timestamp To Value Copy timestamp of record into value. - name: timestampToValue type: dev.vox.platform.kahpp.configuration.transform.TimestampToValueTransform config: field: publication_date Unwrap Value Unwraps the content of one field to root value. - name: payloadUnwrap type: dev.vox.platform.kahpp.configuration.transform.UnwrapValueTransform config: field: payload Wrap Value Wraps the current content in a single field. - name: wrapPayload type: dev.vox.platform.kahpp.configuration.transform.WrapValueTransform config: field: payload Insert Static Value Insert a static value in a chosen field of the value object; if the field exists, the action will be skipped, and eventually is possible to configure the step with overrideIfExists: true to permit the override. Let's take as example this record: { \"name\": \"Paolo\", \"email\": \"paolo@him.com\" } We want to add a new field type , so our record will look like this: { \"name\": \"Paolo\", \"email\": \"paolo@him.com\", \"type\": \"customer\" } So, our step configuration will look like this: - name: addNewField type: dev.vox.platform.kahpp.configuration.transform.InsertStaticFieldTransform config: field: type value: customer Insert JSON Value Eventually, we can also add a static JSON value. - name: addNewJsonField type: dev.vox.platform.kahpp.configuration.transform.InsertStaticFieldTransform config: field: newJsonField value: '[{\"foo\":\"bar\"}]' format: json Override an existing field It's also possible to override an existent field. - name: addNewJsonField type: dev.vox.platform.kahpp.configuration.transform.InsertStaticFieldTransform config: field: email value: '*****' overrideIfExists: true Conditional All transformer steps can be triggered conditionally using the parameter condition . If the expression is true, the action will be started. Example: - name: moveBarToNewBar type: dev.vox.platform.kahpp.configuration.transform.MoveFieldRecordTransform config: condition: \"value.bar != null\" from: value.bar to: value.newBar","title":"Transformers"},{"location":"features/transformers/#transformers","text":"These steps make it possible to re-shape records on your need.","title":"Transformers"},{"location":"features/transformers/#move-field","text":"Permits to move a field. - name: moveBarToNewBar type: dev.vox.platform.kahpp.configuration.transform.MoveFieldRecordTransform config: from: value.bar to: value.newBar","title":"Move Field"},{"location":"features/transformers/#copy-field","text":"Permits to copy a field. - name: copyKeyToValue type: dev.vox.platform.kahpp.configuration.transform.CopyFieldRecordTransform config: from: key to: value.key","title":"Copy Field"},{"location":"features/transformers/#drop-field","text":"Permits to remove a field. - name: removeThisField type: dev.vox.platform.kahpp.configuration.transform.DropFieldRecordTransform config: jmesPath: value.unlike","title":"Drop Field"},{"location":"features/transformers/#convert-zoneddatetime-field","text":"Converts a date from one format to another. - name: ensureCreatedAtDateIsRFC3339 type: dev.vox.platform.kahpp.configuration.transform.ConvertZonedDateTimeFieldTransform config: field: value.createdAt inputFormat: RFC_3339_LENIENT_MS_FORMATTER outputFormat: RFC_3339","title":"Convert ZonedDateTime Field"},{"location":"features/transformers/#extract-field","text":"Pulls a field out of a complex value and replaces the entire value with the extracted field. - name: extractId type: dev.vox.platform.kahpp.configuration.transform.ExtractFieldValueTransform config: field: id","title":"Extract Field"},{"location":"features/transformers/#split-array","text":"Split an array into multiple records. Let's take as example this record: { \"customer\": \"Paolo\", \"orders\": [ { \"type\": \"food\", \"product\": \"pizza\" }, { \"type\": \"drink\", \"product\": \"cocacola\" } ] } We would like to send the order for food and drink in two different places (for example to two different topics). So the expected result is to have two records. One for the food: { \"customer\": \"Paolo\", \"order\": { \"type\": \"food\", \"product\": \"pizza\" } } Another for the drink: { \"customer\": \"Paolo\", \"order\": { \"type\": \"drink\", \"product\": \"cocacola\" } } So, our step configuration will look like: - name: splitFooArray type: dev.vox.platform.kahpp.configuration.transform.SplitValueTransform config: jmesPath: \"value.orders\" to: \"value.order\" # Optional field","title":"Split array"},{"location":"features/transformers/#optional-configurations","text":"name default description to \"\" Defines where to put an extracted array's object as a nested field into the original parent object. If the 'to' field is not configured, the extracted object will go on the 'value' field by default. The existing parent's field under the same 'to' path is going to be overridden.","title":"Optional configurations"},{"location":"features/transformers/#copy-timestamp-to-value","text":"Copy timestamp of record into value. - name: timestampToValue type: dev.vox.platform.kahpp.configuration.transform.TimestampToValueTransform config: field: publication_date","title":"Copy Timestamp To Value"},{"location":"features/transformers/#unwrap-value","text":"Unwraps the content of one field to root value. - name: payloadUnwrap type: dev.vox.platform.kahpp.configuration.transform.UnwrapValueTransform config: field: payload","title":"Unwrap Value"},{"location":"features/transformers/#wrap-value","text":"Wraps the current content in a single field. - name: wrapPayload type: dev.vox.platform.kahpp.configuration.transform.WrapValueTransform config: field: payload","title":"Wrap Value"},{"location":"features/transformers/#insert-static-value","text":"Insert a static value in a chosen field of the value object; if the field exists, the action will be skipped, and eventually is possible to configure the step with overrideIfExists: true to permit the override. Let's take as example this record: { \"name\": \"Paolo\", \"email\": \"paolo@him.com\" } We want to add a new field type , so our record will look like this: { \"name\": \"Paolo\", \"email\": \"paolo@him.com\", \"type\": \"customer\" } So, our step configuration will look like this: - name: addNewField type: dev.vox.platform.kahpp.configuration.transform.InsertStaticFieldTransform config: field: type value: customer","title":"Insert Static Value"},{"location":"features/transformers/#insert-json-value","text":"Eventually, we can also add a static JSON value. - name: addNewJsonField type: dev.vox.platform.kahpp.configuration.transform.InsertStaticFieldTransform config: field: newJsonField value: '[{\"foo\":\"bar\"}]' format: json","title":"Insert JSON Value"},{"location":"features/transformers/#override-an-existing-field","text":"It's also possible to override an existent field. - name: addNewJsonField type: dev.vox.platform.kahpp.configuration.transform.InsertStaticFieldTransform config: field: email value: '*****' overrideIfExists: true","title":"Override an existing field"},{"location":"features/transformers/#conditional","text":"All transformer steps can be triggered conditionally using the parameter condition . If the expression is true, the action will be started. Example: - name: moveBarToNewBar type: dev.vox.platform.kahpp.configuration.transform.MoveFieldRecordTransform config: condition: \"value.bar != null\" from: value.bar to: value.newBar","title":"Conditional"},{"location":"getting-started/docker/","text":"Run Kahpp with Docker Running Kahpp using Docker is the easiest and fastest way to use and play with it. All we need is just our Yaml file of a Kahpp instance and a Kafka cluster available. Here you can find the full example here . Docker docker run -v instance.yaml:/kahpp/application.yaml ghcr.io/getfeedback/kahpp-oss Docker Compose version: '3.7' services: zookeeper: image: zookeeper:3.5 networks: - kahpp kafka: image: wurstmeister/kafka:2.12-2.5.0 restart: always depends_on: - zookeeper environment: KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: kafka KAFKA_AUTO_CREATE_TOPICS_ENABLE: \"true\" KAFKA_MESSAGE_MAX_BYTES: 20000000 KAFKA_CREATE_TOPICS: >- source-topic:1:1:compact, sink-topic:1:1:compact, ports: - \"9092:9092\" networks: - kahpp kahpp: image: ghcr.io/getfeedback/kahpp-oss ports: - \"8080:8080\" depends_on: - kafka volumes: - ./kahpp/:/kahpp/ networks: - kahpp networks: kahpp: name: kahpp","title":"Run Kahpp"},{"location":"getting-started/docker/#run-kahpp-with-docker","text":"Running Kahpp using Docker is the easiest and fastest way to use and play with it. All we need is just our Yaml file of a Kahpp instance and a Kafka cluster available. Here you can find the full example here .","title":"Run Kahpp with Docker"},{"location":"getting-started/docker/#docker","text":"docker run -v instance.yaml:/kahpp/application.yaml ghcr.io/getfeedback/kahpp-oss","title":"Docker"},{"location":"getting-started/docker/#docker-compose","text":"version: '3.7' services: zookeeper: image: zookeeper:3.5 networks: - kahpp kafka: image: wurstmeister/kafka:2.12-2.5.0 restart: always depends_on: - zookeeper environment: KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: kafka KAFKA_AUTO_CREATE_TOPICS_ENABLE: \"true\" KAFKA_MESSAGE_MAX_BYTES: 20000000 KAFKA_CREATE_TOPICS: >- source-topic:1:1:compact, sink-topic:1:1:compact, ports: - \"9092:9092\" networks: - kahpp kahpp: image: ghcr.io/getfeedback/kahpp-oss ports: - \"8080:8080\" depends_on: - kafka volumes: - ./kahpp/:/kahpp/ networks: - kahpp networks: kahpp: name: kahpp","title":"Docker Compose"},{"location":"getting-started/gradle-plugin/","text":"Gradle Plugin Using the plugin to run a Kahpp instance is not required. Kahpp Plugin adds a set of tools useful to manage the cases. Here you can find a Gradle example project . buildscript { repositories { mavenCentral() maven { url \"https://maven.pkg.github.com/GetFeedback/kahpp-oss\" } } dependencies { classpath \"dev.vox.platform.kahpp:kahpp-gradle-plugin:0.0.4\" } } plugins { id 'org.springframework.boot' version '2.6.4' } apply plugin: 'dev.vox.platform.kahpp' repositories { mavenCentral() maven { url \"https://maven.pkg.github.com/GetFeedback/kahpp-oss\" } } dependencies { implementation \"dev.vox.platform.kahpp:kahpp-spring-starter:0.0.4\" testImplementation(\"org.springframework:spring-test:5.3.16\") } Tasks List all tasks: ./gradlew tasks --group=kahpp The plugin provides a series of task that help development. Name Description copyConfigFromHelm Generate Test instances detectHelmToTestDrift Detect if Test and Actual instance don't match generateTestTasks Generate test task for each Instance on the repo testAll Run each instance test","title":"Gradle Plugin"},{"location":"getting-started/gradle-plugin/#gradle-plugin","text":"Using the plugin to run a Kahpp instance is not required. Kahpp Plugin adds a set of tools useful to manage the cases. Here you can find a Gradle example project . buildscript { repositories { mavenCentral() maven { url \"https://maven.pkg.github.com/GetFeedback/kahpp-oss\" } } dependencies { classpath \"dev.vox.platform.kahpp:kahpp-gradle-plugin:0.0.4\" } } plugins { id 'org.springframework.boot' version '2.6.4' } apply plugin: 'dev.vox.platform.kahpp' repositories { mavenCentral() maven { url \"https://maven.pkg.github.com/GetFeedback/kahpp-oss\" } } dependencies { implementation \"dev.vox.platform.kahpp:kahpp-spring-starter:0.0.4\" testImplementation(\"org.springframework:spring-test:5.3.16\") }","title":"Gradle Plugin"},{"location":"getting-started/gradle-plugin/#tasks","text":"List all tasks: ./gradlew tasks --group=kahpp The plugin provides a series of task that help development. Name Description copyConfigFromHelm Generate Test instances detectHelmToTestDrift Detect if Test and Actual instance don't match generateTestTasks Generate test task for each Instance on the repo testAll Run each instance test","title":"Tasks"},{"location":"getting-started/kahpp-instance/","text":"What is a Kahpp Instance? A Kahpp Instance or just Instance is a YAML file, essentially a configuration, but we can think of it as the description of the pipeline. Simple instance Here a straightforward Kahpp instance that consumes from source-topic and sinks records on sink-topic . kahpp: group: dev name: simple-instance topics: source: source-topic sink: sink-topic streamsConfig: bootstrapServers: - kafka:9092 cache-max-size-buffering: 300MB steps: - name: produceRecordToSinkTopic type: dev.vox.platform.kahpp.configuration.topic.ProduceToTopic config: topic: sink Kahpp instance location Default location for an Instance is kahpp/application.yaml . It's possible to override the location using the KAHPP_CONFIG_LOCATION environment variable. Configuration YAML KEY DESCRIPTION kahpp.group Logical name of the group that owns the instance, it can be company or teams or domain etc. kahpp.name Name of the instance kahpp.topics.source Source topic, the entry point of the pipeline kahpp.streamsConfig.bootstrapServers The Kafka bootstrap servers. kahpp.streamsConfig.* All other kahpp.streamsConfig, follow the official Kafka configuration parameter reference kahpp.steps List of the steps, describe the pipeline.","title":"Kahpp instance"},{"location":"getting-started/kahpp-instance/#what-is-a-kahpp-instance","text":"A Kahpp Instance or just Instance is a YAML file, essentially a configuration, but we can think of it as the description of the pipeline.","title":"What is a Kahpp Instance?"},{"location":"getting-started/kahpp-instance/#simple-instance","text":"Here a straightforward Kahpp instance that consumes from source-topic and sinks records on sink-topic . kahpp: group: dev name: simple-instance topics: source: source-topic sink: sink-topic streamsConfig: bootstrapServers: - kafka:9092 cache-max-size-buffering: 300MB steps: - name: produceRecordToSinkTopic type: dev.vox.platform.kahpp.configuration.topic.ProduceToTopic config: topic: sink","title":"Simple instance"},{"location":"getting-started/kahpp-instance/#kahpp-instance-location","text":"Default location for an Instance is kahpp/application.yaml . It's possible to override the location using the KAHPP_CONFIG_LOCATION environment variable.","title":"Kahpp instance location"},{"location":"getting-started/kahpp-instance/#configuration","text":"YAML KEY DESCRIPTION kahpp.group Logical name of the group that owns the instance, it can be company or teams or domain etc. kahpp.name Name of the instance kahpp.topics.source Source topic, the entry point of the pipeline kahpp.streamsConfig.bootstrapServers The Kafka bootstrap servers. kahpp.streamsConfig.* All other kahpp.streamsConfig, follow the official Kafka configuration parameter reference kahpp.steps List of the steps, describe the pipeline.","title":"Configuration"}]}